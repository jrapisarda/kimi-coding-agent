from __future__ import annotations

import json
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List


@dataclass
class ScaffoldResult:
    project_type: str
    files_created: List[str]
    notes: str
    dependencies: Dict[str, Dict[str, str]]


def scaffold_project(project_type: str, target_path: Path) -> ScaffoldResult:
    target_path = Path(target_path)
    target_path.mkdir(parents=True, exist_ok=True)
    files: List[str] = []
    dependencies: Dict[str, Dict[str, str]] = {}
    notes = ""

    if project_type == "nextjs-dashboard":
        files.extend(_write_nextjs(target_path))
        dependencies["npm"] = {
            "next": "15.0.0",
            "react": "18.3.0",
            "react-dom": "18.3.0",
        }
        notes = "Generated placeholder Next.js structure with dashboard page."
    elif project_type == "fastapi-crud-api":
        files.extend(_write_fastapi(target_path))
        dependencies["pip"] = {
            "fastapi": "0.110.0",
            "uvicorn": "0.30.0",
            "pydantic": "2.7.0",
        }
        notes = "Generated FastAPI CRUD skeleton with example model and router."
    elif project_type == "python-etl-sqlite":
        files.extend(_write_etl(target_path))
        dependencies["pip"] = {
            "pandas": "2.2.2",
            "sqlite-utils": "3.36.0",
        }
        notes = "Generated ETL script loading CSV into SQLite."
    elif project_type == "sklearn-ml-experiment":
        files.extend(_write_ml(target_path))
        dependencies["pip"] = {
            "scikit-learn": "1.5.0",
            "pandas": "2.2.2",
        }
        notes = "Generated sklearn training scaffold with sample dataset."
    else:
        files.extend(_write_generic(target_path))
        notes = "Generated generic project scaffold."

    return ScaffoldResult(
        project_type=project_type,
        files_created=files,
        notes=notes,
        dependencies=dependencies,
    )


def _write_file(path: Path, content: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")


def _write_nextjs(root: Path) -> List[str]:
    files = []
    _write_file(
        root / "package.json",
        json.dumps(
            {
                "name": "nextjs-dashboard",
                "version": "0.1.0",
                "scripts": {
                    "dev": "echo \"Next.js placeholder\"",
                    "test": "npm run lint",
                    "lint": "echo \"lint placeholder\"",
                },
                "dependencies": {
                    "next": "15.0.0",
                    "react": "18.3.0",
                    "react-dom": "18.3.0",
                },
                "devDependencies": {
                    "typescript": "5.4.0",
                    "eslint": "9.0.0",
                },
                "license": "MIT",
            },
            indent=2,
        ),
    )
    files.append("package.json")
    _write_file(
        root / "app" / "page.tsx",
        """export default function DashboardPage() {
  return (
    <main>
      <h1>Dashboard Placeholder</h1>
      <p>This project scaffold is generated by the Kimi agent pipeline.</p>
    </main>
  );
}
""",
    )
    files.append("app/page.tsx")
    _write_file(
        root / "tests" / "test_dashboard.py",
        """def test_dashboard_metadata():
    assert "dashboard" in "dashboard placeholder".lower()
""",
    )
    files.append("tests/test_dashboard.py")
    return files


def _write_fastapi(root: Path) -> List[str]:
    files = []
    _write_file(
        root / "app" / "main.py",
        """from dataclasses import dataclass
from typing import List

from . import storage


@dataclass
class Item:
    id: int
    name: str


def list_items() -> List[Item]:
    return [Item(id=item["id"], name=item["name"]) for item in storage.load_items()]
""",
    )
    files.append("app/main.py")
    _write_file(root / "app" / "__init__.py", "")
    files.append("app/__init__.py")
    _write_file(
        root / "app" / "storage.py",
        """def load_items() -> list[dict[str, object]]:
    return [{"id": 1, "name": "Sample"}]
""",
    )
    files.append("app/storage.py")
    _write_file(
        root / "tests" / "test_api.py",
        """from app.main import list_items


def test_list_items_returns_sample():
    items = list_items()
    assert items[0].name == "Sample"
""",
    )
    files.append("tests/test_api.py")
    _write_file(
        root / "requirements.txt",
        "fastapi==0.110.0\nuvicorn==0.30.0\npydantic==2.7.0\n",
    )
    files.append("requirements.txt")
    return files
def _write_etl(root: Path) -> List[str]:
    files = []
    _write_file(
        root / "jobs" / "etl.py",
        """import csv
import sqlite3
from pathlib import Path

def load_csv_to_sqlite(csv_path: Path, db_path: Path) -> None:
    with sqlite3.connect(db_path) as conn, csv_path.open("r", encoding="utf-8") as handle:
        reader = csv.DictReader(handle)
        rows = list(reader)
        if not rows:
            return
        columns = rows[0].keys()
        conn.execute(f"DROP TABLE IF EXISTS records")
        conn.execute(
            f"CREATE TABLE records ({', '.join(f'{column} TEXT' for column in columns)})"
        )
        placeholders = ", ".join("?" for _ in columns)
        conn.executemany(
            f"INSERT INTO records ({', '.join(columns)}) VALUES ({placeholders})",
            [[row[column] for column in columns] for row in rows],
        )


if __name__ == "__main__":
    data_dir = Path(__file__).resolve().parent.parent / "data"
    data_dir.mkdir(parents=True, exist_ok=True)
    csv_path = data_dir / "sample.csv"
    if not csv_path.exists():
        csv_path.write_text("id,value\\n1,X\\n2,Y\\n", encoding="utf-8")
    load_csv_to_sqlite(csv_path, data_dir / "database.sqlite")
""",
    )
    files.append("jobs/etl.py")
    _write_file(root / "jobs" / "__init__.py", "")
    files.append("jobs/__init__.py")

    _write_file(
        root / "tests" / "test_etl.py",
        """from pathlib import Path

from jobs.etl import load_csv_to_sqlite


def test_load_csv_to_sqlite(tmp_path: Path):
    csv_path = tmp_path / "data.csv"
    csv_path.write_text("id,value\\n1,A\\n2,B\\n", encoding="utf-8")
    db_path = tmp_path / "test.sqlite"
    load_csv_to_sqlite(csv_path, db_path)
    assert db_path.exists()
""",
    )
    files.append("tests/test_etl.py")
    _write_file(
        root / "requirements.txt",
        "pandas==2.2.2\nsqlite-utils==3.36.0\n",
    )
    files.append("requirements.txt")
    return files


def _write_ml(root: Path) -> List[str]:
    files = []
    _write_file(
        root / "experiments" / "train.py",
        """from statistics import mean

DATASET = [
    {"features": [5.1, 3.5, 1.4, 0.2], "label": 0},
    {"features": [6.2, 3.4, 5.4, 2.3], "label": 1},
    {"features": [5.9, 3.0, 4.2, 1.5], "label": 1},
    {"features": [5.0, 3.4, 1.5, 0.2], "label": 0},
]


def train_model() -> float:
    threshold = mean(row["features"][0] for row in DATASET)
    correct = 0
    for row in DATASET:
        prediction = 1 if row["features"][0] >= threshold else 0
        if prediction == row["label"]:
            correct += 1
    return correct / len(DATASET)


if __name__ == "__main__":
    score = train_model()
    with open("metrics.txt", "w", encoding="utf-8") as handle:
        handle.write(f"accuracy={score:.2f}\\n")
    print(f"Training complete with accuracy {score:.2f}")
""",
    )
    files.append("experiments/train.py")
    _write_file(root / "experiments" / "__init__.py", "")
    files.append("experiments/__init__.py")
    _write_file(
        root / "tests" / "test_train.py",
        """from experiments.train import train_model


def test_train_model():
    score = train_model()
    assert 0 <= score <= 1
""",
    )
    files.append("tests/test_train.py")
    _write_file(
        root / "requirements.txt",
        "scikit-learn==1.5.0\npandas==2.2.2\n",
    )
    files.append("requirements.txt")
    return files
def _write_generic(root: Path) -> List[str]:
    files = []
    _write_file(
        root / "README.md",
        "# Generic scaffold\\n\\nGenerated by Kimi agent sprint three.",
    )
    files.append("README.md")
    return files
